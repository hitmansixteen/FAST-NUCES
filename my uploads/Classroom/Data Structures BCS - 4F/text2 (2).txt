Router>enable                                      
Router#configure terminal 				// Global configuration mode
Enter configuration commands, one per line. End with CNTL/Z.
Router(config)#router rip
Router(config-router)#version 2
Router(config-router)#no auto-summary
Router(config-router)#network 172.19.0.0
Router(config-router)#network 172.19.32.0
Router(config-router)#network 172.19.160.0
Router(config-router)#exit
Router(config)#exit

for DHCP

Router>enable

Router#configure terminal
#interface fastethernet0/0
#ip address 192.168.1.1 255.255.255.0
#no shutdown
#exit


ip dhcp pool name
network 192.168.1.2 255.255.255.0

default-router 192.168.1.1
exit

=================================================================================================================================
puts "Enter the number: "
set num [gets stdin]
set number [expr {$num}]
while { $number<4 } {
puts "Entered number should be greater than 4, write again"
set num [gets stdin]
}
set number [expr {$num}]
if {$number %2 == 0} {
    for {set i 4 } { $i<= $number } {incr i 1} {
       if {$i %2 == 0} {
        puts $i
       }
    }
} else {
    for {set i 3 } { $i<= $number } {incr i 1} {
        if {$i %2 == 1} {
        puts $i 
        }
    }
}


-------------------------------------------------------------------------------------------------------------------------------
============================================================================================================================

#This program will create two nodes and pass traffice from one node to other node using TCP protocol

#Creating simulator object 
set ns [new Simulator]   

#Creating the nam file
set nf [open out.nam w]      
#It opens the file 'out.nam' for writing and gives it the file handle 'nf'. 
$ns namtrace-all $nf

# Open the trace file
#  set nf [open out.tr w]
# $ns trace-all $nf

#    we are opening a newtrace file named as "out" and also telling that data must be stored in .tr [trace] format.
#   "nf" is the file handler that we are used here to handle the trace file.
#   "w" means write i.e the file out.tr is opened for writing.
#   "r" means reading 
#   The second line tells the simulator to trace each packet on every link in the topology and for that we give file handler nf for the simulator ns.



#Finish Procedure  (closes the trace file and starts nam)
proc finish {} {
        global ns nf
        $ns flush-trace
        close $nf
        exec nam out.nam &
        exit 0
        }
			
#The trace data is flushed into the file by using command $ns flush-trace and then file is closed.
        
#Creating Two nodes
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]

#Creating a duplex link between two nodes (connect the nodes n0 and n1 with a duplex link with the bandwidth 1Megabit, a delay of 10ms and a SFQ queue)
$ns duplex-link $n0 $n2 2Mb 10ms DropTail
$ns duplex-link $n1 $n2 2Mb 10ms DropTail
$ns duplex-link $n2 $n3 1.7Mb 20ms DropTail

#$ns queue-limit <$node1> <$node2> <num_of_packets>
$ns queue-limit $n0 $n2 10
$ns queue-limit $n1 $n2 10
$ns queue-limit $n2 $n3 10


$ns duplex-link-op $n0 $n2 orient right-down
$ns duplex-link-op $n1 $n2 orient right-up
$ns duplex-link-op $n2 $n3 orient right



#Monitor the queue for link (n2-n3). (for NAM)
#$ns duplex-link-op $n2 $n3 queuePos 0.5

#specifying transport layer
#Creating a TCP agent and connecting it to n0 (Basically it defines source node of TCP)
set tcp0 [new Agent/TCP]
$ns attach-agent $n1 $tcp0        

#Creating a Sink Agent and attaching it to n1
set sink0 [new Agent/TCPSink]
$ns attach-agent $n3 $sink0

set udp0 [new Agent/UDP]
$ns attach-agent $n0 $udp0        

set null [new Agent/Null]
$ns attach-agent $n3 $null

#Connecting TCP agent with Sink agent
$ns connect $tcp0 $sink0
$ns connect $udp0 $null

#Creating FTP agent for traffic and attching it to tcp0
set ftp0 [new Application/FTP]
$ftp0 attach-agent $tcp0


set cbr [new Application/Traffic/CBR]
$cbr attach-agent $udp0
$cbr set packetSize_ 1000
$cbr set type_ CBR
$cbr set rate_ 0.1mb



#Starting the FTP Traffic
$ns at 0.5 "$ftp0 start"
$ns at 4.0 "$ftp0 stop"


$ns at 0.1 "$cbr start"
$ns at 4.5 "$cbr stop"

$udp0 set fid_ 0
$tcp0 set fid_ 1

$ns color 0 red
$ns color 1 blue

#Calling the finish procedure ( e.g. 5 seconds)
$ns at 5.0 "finish"

#Run the simulation
$ns run


---------------------------------------------------------------------------------------------------------------------------------
==============================================================================================================================================
set ns [new Simulator]
set nf [open out.nam w]

$ns color 0 blue
$ns color 1 red
$ns namtrace-all $nf

proc finish {} {

global ns nf
$ns flush-trace
close $nf
exec nam out.nam &
exit 0
}
set n0 [$ns node]
set n1 [$ns node]
set n2 [$ns node]
set n3 [$ns node]
set n4 [$ns node]

$ns rtproto DV


#$ns duplex-link $n0 $n3 512kb 10ms SFQ
$ns duplex-link $n0 $n4 512kb 10ms SFQ
$ns duplex-link-op $n0 $n4 orient right-down


$ns duplex-link $n4 $n3 512kb 10ms SFQ
$ns duplex-link-op $n4 $n3 orient right-down

$ns duplex-link $n2 $n4 512kb 10ms SFQ
$ns duplex-link-op $n2 $n4 orient left-down

$ns duplex-link $n4 $n1 512kb 10ms SFQ
$ns duplex-link-op $n4 $n1 orient left-down

$ns duplex-link $n0 $n1 512kb 10ms SFQ
$ns duplex-link-op $n0 $n1 orient down

$ns duplex-link $n2 $n3 512kb 10ms SFQ
$ns duplex-link-op $n2 $n3 orient down

$ns duplex-link $n0 $n2 512kb 10ms SFQ
$ns duplex-link-op $n0 $n2 orient right

$ns duplex-link $n1 $n3 512kb 10ms SFQ
$ns duplex-link-op $n1 $n3 orient right

set TCP0 [new Agent/TCP]
$TCP0 set fid_ 1

$ns attach-agent $n0 $TCP0
$ns attach-agent $n1 $TCP0

set TCP1 [new Agent/TCPSink]
$TCP1 set fid_ 1

$ns attach-agent $n0 $TCP1
$ns attach-agent $n1 $TCP1
$ns attach-agent $n2 $TCP1
$ns attach-agent $n3 $TCP1
$ns attach-agent $n4 $TCP1

$ns connect $TCP0 $TCP1
set UDP0 [new Agent/UDP]
$UDP0 set fid_ 0

$ns attach-agent $n0 $UDP0
$ns attach-agent $n1 $UDP0



set UDP1 [new Agent/Null]
$UDP1 set fid_ 0

$ns attach-agent $n0 $UDP1
$ns attach-agent $n1 $UDP1
$ns attach-agent $n2 $UDP1
$ns attach-agent $n3 $UDP1
$ns attach-agent $n4 $UDP1

$ns connect $UDP0 $UDP1
set ftp0 [new Application/FTP]
$ftp0 attach-agent $TCP0

set cbr0 [new Application/Traffic/CBR]
$cbr0 attach-agent $UDP0

$cbr0 set rate_ 256Kbps

$ns at 0.2 "$ftp0 start"
$ns at 2.8 "$ftp0 stop"
$ns at 0.5 "$cbr0 start"
$ns at 2.6 "$cbr0 stop"


$ns rtmodel-at 1 up $n0 $n4
$ns rtmodel-at 2 down $n0 $n4


$ns rtmodel-at 1.3 down $n1 $n4
$ns rtmodel-at 2.3 up $n1 $n4


$ns rtmodel-at 1.5 down $n2 $n4
$ns rtmodel-at 2.4 up $n2 $n4


$ns rtmodel-at 1.7 down $n3 $n4
$ns rtmodel-at 2.6 up $n3 $n4

$ns at 3.0 "finish"

$ns run






------------------------------------------------------------------------------------------------------------------------------------------
===========================================================================================================================================
CLIENT


/*
        TCP_Client. This Program will implement the Client Side for TCP_Socket Programming.
        It will get some data from user and will send to the server and as a reply from the
        server, it will get its data back.
*/

#include <stdio.h>
#include <string.h>
#include <sys/socket.h> //socket
#include <arpa/inet.h> //inet_addr

int main(void)
{
        int socket_desc;
        struct sockaddr_in server_addr;
        char server_message[2000], client_message[2000],candidates[10][100];
        char msg[1000];
        //Cleaning the Buffers
        
        memset(server_message,'\0',sizeof(server_message));
        memset(client_message,'\0',sizeof(client_message));
        memset(msg,'\0',sizeof(msg));
        
        //Creating Socket
        
        socket_desc = socket(AF_INET, SOCK_STREAM, 0);
        
        if(socket_desc < 0)
        {
                printf("Could Not Create Socket. Error!!!!!\n");
                return -1;
        }
        
        printf("Socket Created\n");
        
        //Specifying the IP and Port of the server to connect
        
        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(2000);
        server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
        
        //Now connecting to the server accept() using connect() from client side
        
        if(connect(socket_desc, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0)
        {
                printf("Connection Failed. Error!!!!!");
                return -1;
        }
        
        printf("Connected\n");
        
        //Get Input from the User
        
        printf("Enter Name: ");
        gets(msg);                                     //One is that gets() will only get character string data. 
        strcpy(client_message,msg);
  	strcat(client_message,"/");
        memset(msg,'\0',sizeof(msg));                                          //		will get only one variable at a time.
        printf("Enter Cnic: ");
        gets(msg); 
        strcat(client_message,msg);        
        if(send(socket_desc, client_message, strlen(client_message),0) < 0)
        {
                printf("Send Failed. Error!!!!\n");
                return -1;
        }
        //Receive the message back from the server
        
        if(recv(socket_desc, server_message, sizeof(server_message),0) < 0)
        {
                printf("Receive Failed. Error!!!!!\n");
                return -1;
        }
 	if (strcmp(server_message,"Not Found")==0){
 		printf("Sorry No voter with %s found\n",client_message);
 	
 	}       
        else{
        	printf("Welcome %s\nKindly Cast Your Vote\n",client_message);
        	printf("Name\tPoll Symbol\n");
        	if(send(socket_desc, "Received", strlen("Received"),0) < 0)
		{
		        printf("Send Failed. Error!!!!\n");
		        return -1;
		}
        	memset(server_message,'\0',sizeof(server_message));
        	memset(client_message,'\0',sizeof(client_message));
        	memset(candidates,'\0',sizeof(candidates));
		char number[10];memset(number,'\0',sizeof(number));
        	if(recv(socket_desc, candidates, sizeof(candidates),0) < 0)
		{
			printf("Candidates Receive Failed. Error!!!!!\n");
			return -1;
		}
		if(send(socket_desc, "Candidates Received", strlen("Candidates Received"),0) < 0)
		{
		        printf("Send Failed. Error!!!!\n");
		        return -1;
		}
		if(recv(socket_desc, number, sizeof(number),0) < 0)
		{
			printf("Number of Candidates Receive Failed. Error!!!!!\n");
			return -1;
		}
		int no_of_candidates=atoi(number);int j;
		for (j=0;j<no_of_candidates;j++){
			printf("%s\n",candidates[j]);
		}
		printf("\nEnter Poll Symbol =\t");
		gets(server_message);
		if(send(socket_desc, server_message, strlen(server_message),0) < 0)
		{
		        printf("Send Failed. Error!!!!\n");
		        return -1;
		}
        	if(recv(socket_desc, server_message, sizeof(server_message),0) < 0)
		{
		        printf("Receive Failed. Error!!!!!\n");
		        return -1;
		}
		printf("%s\n",server_message);
        }
        
        memset(server_message,'\0',sizeof(server_message));
        memset(client_message,'\0',sizeof(client_message));
        
        //Closing the Socket
        
        close(socket_desc);
        
        return 0;
}











============================================================================================================================================

/*
        TCP_Server. This Program will will create the Server side for TCP_Socket Programming.
        It will receive the data from the client and then send the same data back to client.
*/

#include <sys/socket.h> //socket
#include <arpa/inet.h> //inet_addr
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

char voters[30][100];
char candidates[10][100];
char have_already_voted[30][100];
int no_of_voters=0;
int already_voted_no=0;
int no_of_candidates=0;

void show_voters_and_candidates(){
	int i;
	for (i=0;i<no_of_candidates;i++){
		printf("Number %d Candidate is %s\n",i+1,candidates[i]);
	
	}
	for (i=0;i<no_of_voters;i++){
		printf("Number %d Voter is %s\n",i+1,voters[i]);
	
	}
	
}
bool check_voter(char name_cnic[]){
	int i;
	for(i=0;i<no_of_voters;i++){
		if(strcmp(voters[i],name_cnic)==0){
			printf("%s found in the voters list\n",name_cnic);
			return true;
		}
	
	}

	printf("No voter with %s found in the voters list\n",name_cnic);
	return false;
}
bool check_already_voted(char name[]){
	int i;
	for (i=0;i<already_voted_no;i++){
		if (strcmp(have_already_voted[i],name)==0){
			return true;
		}	
	
	}
	return false;

}
int check_and_store_vote(char name[], char cl_msg[]){
	if (check_already_voted(name)){
		return 0;
	}
	int i;
	char temp_candidates[10][100];
	memset(temp_candidates,'\0',sizeof(temp_candidates));
	for(i=0;i<no_of_candidates;i++){
		strcpy(temp_candidates[i],candidates[i]);
	}//Creating a temporary one because strtok would disturb the orignal
	for (i=0;i<no_of_candidates;i++){
		char * token=strtok(temp_candidates[i],"\t");
		token=strtok(NULL,"\t");
		//printf("The Symbol from array is%s\n",token);
		//printf("The Symbol from client is%s\n",cl_msg);
		if(strcmp(token,cl_msg)==0){
			//Writing to a file
			strcpy(have_already_voted[already_voted_no++],name);
			FILE* fileptr = fopen("Votes.txt", "a");
			if (fileptr==NULL){
				printf("File not opened");
			}
			else{
				fprintf(fileptr,"%s Voted for %s\n",name,cl_msg);					
				fclose(fileptr);
				return 1;
			}
		
		}
	}

	return -1;
}
int read_file(char filename [],char arr2[][100]){
	char arr[100];
	FILE* fileptr = fopen(filename, "r");
	int i=0;
	int len=0;int index=0;
	
	if (fileptr == NULL) 
	    { 
		printf("Cannot open file \n"); 
		exit(0); 
	    }
		
	while (fgets(arr,100,fileptr)!=NULL){
			index++;
			if (arr==EOF){
				break;
			}
			
		strcpy(arr2[i++],arr); //arr2 is passed by reference in parameters
		len=strlen(arr2[i-1]);
		
		if (!(filename=="Candidates_List.txt"&&index==3)){
			arr2[i-1][len-2]='\0';
			arr2[i-1][len-1]='\0'; //The file which has been provided has 2 extra characters (new line plus carriage return at the end of each line so this is to eliminate them )
		}
		memset(arr,'\0',sizeof(arr));		
	}
	fclose(fileptr);
	return i;
}
void* manageclient (void *pid2)
{
	int client_sock=(int *) pid2;
        char server_message[2000], client_message[2000],name[2000];  
		memset(server_message,'\0',sizeof(server_message));
		memset(client_message,'\0',sizeof(client_message));
		memset(name,'\0',sizeof(name));
		if (recv(client_sock, client_message, sizeof(client_message),0) < 0)
		{
		        printf("Receive Failed. Error!!!!!\n");
		        return -1;
		}
		
		strcpy(name,client_message);
		printf("Client Message: %s\n",client_message);
		
		if(check_voter(client_message)){
			strcpy(server_message, "Found");

			if (send(client_sock, server_message, strlen(server_message),0)<0)
			{
				printf("Send Failed. Error!!!!!\n");
				return -1;
			}
			
			memset(server_message,'\0',sizeof(server_message));
			memset(client_message,'\0',sizeof(client_message));
			if (recv(client_sock, client_message, sizeof(client_message),0) < 0)
			{
				printf("Receive Failed. Error!!!!!\n");
				return -1;
			}
			printf("Client Message %s",client_message);
			if (send(client_sock, candidates, sizeof(candidates),0)<0)
			{
				printf("Candidates Send Failed. Error!!!!!\n");
				return -1;
			}
			memset(client_message,'\0',sizeof(client_message));
			if (recv(client_sock, client_message, sizeof(client_message),0) < 0)
			{
				printf("Receive Failed. Error!!!!!\n");
				return -1;
			}
			printf("Client Message %s",client_message);
			char number[10];
			memset(number,'\0',sizeof(number));
			snprintf(number, 10,"%d",no_of_candidates);
			
			
			if (send(client_sock, number, sizeof(number),0)<0)
			{
				printf("No of Candidates Send Failed. Error!!!!!\n");
				return -1;
			}
			memset(client_message,'\0',sizeof(client_message));
			if (recv(client_sock, client_message, sizeof(client_message),0) < 0)
			{
				printf("Receive Failed. Error!!!!!\n");
				return -1;
			}
			int no=check_and_store_vote(name,client_message);	
			if(no==1){
				if (send(client_sock, "Your vote has been casted and saved in file", strlen("Your vote has been casted and saved in file"),0)<0)
				{
					printf("No of Candidates Send Failed. Error!!!!!\n");
					return -1;
				}
			}
			else if (no==0){
				if (send(client_sock, "You have already Voted you can't vote again", strlen("You have already Voted you can't vote again"),0)<0)
				{
					printf("No of Candidates Send Failed. Error!!!!!\n");
					return -1;
				}
			
			}
			else {
				if (send(client_sock, "Incorrect Poll Symbol", strlen("Incorrect Poll Symbol"),0)<0)
				{
					printf("No of Candidates Send Failed. Error!!!!!\n");
					return -1;
				}
			
			}
		}
		else{
			strcpy(server_message, "Not Found");
			if (send(client_sock, server_message, strlen(server_message),0)<0)
			{
				printf("Send Failed. Error!!!!!\n");
				return -1;
			}
		
			memset(server_message,'\0',sizeof(server_message));
			memset(client_message,'\0',sizeof(client_message));
		
		}
        pthread_exit(NULL);
        
}
int main(void)
{
		memset(voters,'\0',sizeof(voters));
		memset(candidates,'\0',sizeof(candidates)); //initializing the candidates and voters
        memset(have_already_voted,'\0',sizeof(have_already_voted));
		
        no_of_voters=read_file("Voters_List.txt",voters);
        no_of_candidates=read_file("Candidates_List.txt",candidates);
		
        //show_voters_and_candidates();
        int socket_desc, client_sock, client_size; 
        struct sockaddr_in server_addr, client_addr;         //SERVER ADDR will have all the server address
        char server_message[2000], client_message[2000];                 // Sending values from the server and receive from the server we need this

        //Cleaning the Buffers
        
        memset(server_message,'\0',sizeof(server_message));
        memset(client_message,'\0',sizeof(client_message));     // Set all bits of the padding field//
        
        //Creating Socket
        
        socket_desc = socket(AF_INET, SOCK_STREAM, 0);
        
        if(socket_desc < 0)
        {
                printf("Could Not Create Socket. Error!!!!!\n");
                return -1;
        }
        
        printf("Socket Created\n");
        
        //Binding IP and Port to socket
        
        server_addr.sin_family = AF_INET;               /* Address family = Internet */
        server_addr.sin_port = htons(2000);               // Set port number, using htons function to use proper byte order */
        server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");    /* Set IP address to localhost */
		
		
		
		// BINDING FUNCTION
        
        if(bind(socket_desc, (struct sockaddr*)&server_addr, sizeof(server_addr))<0)    // Bind the address struct to the socket.  /
	                            	//bind() passes file descriptor, the address structure,and the length of the address structure
        {
                printf("Bind Failed. Error!!!!!\n");
                return -1;
        }        
        
        printf("Bind Done\n");
        
        //Put the socket into Listening State
        
        if(listen(socket_desc, 1) < 0)                               //This listen() call tells the socket to listen to the incoming connections.
     // The listen() function places all incoming connection into a "backlog queue" until accept() call accepts the connection.
        {
                printf("Listening Failed. Error!!!!!\n");
                return -1;
        }
        
        while(1){		
	        printf("Listening for Incoming Connections.....\n");
		client_sock = accept(socket_desc, (struct sockaddr*)&client_addr, &client_size);          // heree particular client k liye new socket create kr rhaa ha
		
		if (client_sock < 0)
		{
		        printf("Accept Failed. Error!!!!!!\n");
		        return -1;
		}
		
		printf("Client Connected with IP: %s and Port No: %i\n",inet_ntoa(client_addr.sin_addr),ntohs(client_addr.sin_port));
			       //inet_ntoa() function converts the Internet host address in, given in network byte order, to a string in IPv4 dotted-decimal notation
		
		pthread_t threads;
	    	pthread_create(&threads,NULL,&manageclient,(void*)client_sock);
	    	
        }
               return 0;       
}

---------------------------------------------------------------------------------------------------------------------------------------------
============================================================================================================================================
//main: main.o functions.o
//gcc main.o funcitons.o -o main

main.o: main.c
gcc -c main.c

functions.o:function.c
gcc -c functions.c

clean:
rm *.o main


make -f m1.mk if multiple files are there 
else only make 

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <sys/wait.h>


  char *str2[] = {"r", argv[1], NULL};
        execv("./r", str2); //r.c will be a file


       
       // reading alternate alphabets from a file,lab4
       int main(argc,argv)
    int fd = open("read.txt", O_RDONLY);
    char buf[1];
    int idx, reads;

    for (reads = 0; reads = read(fd, buf, 1) > 0; idx = lseek(fd, 1, SEEK_CUR))
        if (idx % 2 == 0)
            write(1, buf, 1);

    write(1, "\n", 1); //first 1 writes on screen
    return 0;
}

FUNCTION USAGE
fopen() create a new file or open an existing file
fclose() closes a file
fgetc() reads a character from a file
fputc() writes a character to a file
fputs() writes a line of characters to a file
fgets() Reads a line of characters from a file
fscanf() reads a set of data from a file
fprintf() writes a set of data to a file

pg. 2
getw() reads a integer from a file
putw() writes a integer to a file
fseek() set the position to desire point
ftell() returns current position of file

1) *fp = FILE *fopen(const char *filename, const char *mode);
Following are the modes for fopen:

i. r or rb
Open file for reading.
ii. w or wb
Truncate to zero length or create file for writing.
iii. a or ab
Append; open or create file for writing at end-of-file.
iv. r+ or rb+ or r+b
Open file for update (reading and writing).
v. w+ or wb+ or w+b
Truncate to zero length or create file for update.
vi. a+ or ab+ or a+b
Append; open or create file for update, writing at end-of-file.

**Note: “b” is for binary files

2) int fclose( FILE *fp);
3) int fgetc(FILE *stream)
4) int fputc(int c, FILE *stream)
5) char* fgets(char *s, int n, FILE *stream)
6) int fputs(const char *s, FILE *stream)
7) int fscanf(FILE *stream, const char *format [, argument, ...])
8) int fprintf(FILE *stream, const char *format [, argument, ...])
9) int getw(FILE *fp);
10) int putw(int number, FILE *fp);
11) int fseek(FILE *stream, long int offset, int whence)
12) long ftell(FILE *stream)




//lab5
using pipes to remove special characters with space 
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <sys/wait.h>
int main()
{
    int pipes[2], pipes2[2];
    char buff[1024];
    pipe(pipes);
    pipe(pipes2);
    pid_t p1 = fork();

    if (p1 < 0)
        perror("fork error");

    if (p1 == 0)
    {

        read(pipes[0], buff, sizeof(buff));

        int i = 0;
        int len = strlen(buff);
        while (i < len)
        {
            if (buff[i] >= 33 && buff[i] <= 47)
            {
                buff[i] = ' ';
            }

            i++;
        }
        buff[i] = '\0';
        write(pipes2[1], buff, strlen(buff));
    }
    else if (p1 > 0)
    {
        int f1 = open("read.txt", O_RDONLY);
        read(f1, buff, sizeof(buff));
        write(pipes[1], buff, strlen(buff));

        p1 = wait(NULL);
        read(pipes2[0], buff, strlen(buff));
        int f2 = open("updated.txt", O_WRONLY);
        write(f2, buff, strlen(buff));
    }
    return 0;
}




#include <pthread.h>
#include <stdio.h>
#include <string.h>
void *printer(void *arg)
{

    printf("Thread ID is %lu and Process ID is %d \n", pthread_self(), getpid());
}
int main()
{
    int N;
    printf("Enter N number of threads!\n");
    scanf("%d", &N);

    pthread_t arr[N];
    int i = 0;
    for (i = 0; i < N; i++)
    {
        pthread_create(&arr[i], NULL, &printer, NULL);
    }

    pthread_join(arr[N - 1], NULL);
    return 0;
}


#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <string.h>
int main(int argc, char *argv[])
{
    int fd[2];
    if (pipe(fd) == -1)
    {
        printf("Error creating pipe!\n");
    }
    pid_t pid = fork();
    if (pid)
    {
        //! PARENT
        close(fd[0]);
        if (write(fd[1], argv[1], sizeof(argv[1])) == -1)
        {
            return 1;
        }
        printf("Data written to pipe is: %s\n", argv[1]);
        wait(NULL);
    }
    else if (!pid)
    {
        //! CHILD
        close(fd[1]);
        char array[1000];
        if (read(fd[0], array, sizeof(array)) == -1)
        {
            return 1;
        }
        printf("Data successfully read!\n");
        for (int i = 0; i < strlen(array); i++)
        {
            if (array[i] >= 'a' && array[i] <= 'z')
            {
                array[i] -= 32;
            }
            else
                array[i] += 32;
        }
        printf("Modified String: %s", array);
    }
}


#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
int SIZE;
void *fibonacci_generator(void *arg)
{
    int *n = (int *)arg;
    SIZE = *n;
    int *array = malloc(*n * sizeof(int));
    printf("Thread id of current thread: %d!\n", pthread_self());
    int f = 0, s = 1;
    for (int i = 0; i < *n; i++)
    {
        if (i <= 1)
            array[i] = i;
        else
        {
            array[i] = f + s;
            f = s;
            s = array[i];
        }
        printf("%d ", array[i]);
    }
    printf("\n");
    return (void *)array;
}
void *even_numbers(void *arg)
{
    printf("Thread id of current thread: %d!\n", pthread_self());
    int *array = (int *)arg;
    int *even = malloc(sizeof(int));
    *even = 0;
    for (int i = 0; i < SIZE; i++)
    {
        if (array[i] % 2 == 0)
            *even = *even + 1;
    }
    return (void *)even;
}
void *odd_numbers(void *arg)
{
    printf("Thread id of current thread: %d!\n", pthread_self());
    int *array = (int *)arg;
    int *odd = malloc(sizeof(int));
    *odd = 0;
    for (int i = 0; i < SIZE; i++)
    {
        if (array[i] % 2 != 0)
            *odd = *odd + 1;
    }
    return (void *)odd;
}
void *sum(void *arg)
{
    printf("Thread id of current thread: %d!\n", pthread_self());
    int *array = (int *)arg;
    int *sum = malloc(sizeof(int));
    *sum = 0;
    for (int i = 0; i < SIZE; i++)
    {
        *sum = *sum + array[i];
    }
    return (void *)sum;
}
int main(int argc, char *argv[])
{
    int n = atoi(argv[1]);
    //! Thread1
    pthread_t thread1;
    pthread_create(&thread1, NULL, fibonacci_generator, (void *)&n);
    int *array=NULL;
    pthread_join(thread1, (void **)&array);
    //! Thread2
    pthread_t thread2;
    pthread_create(&thread2, NULL, even_numbers, (void *)array);
    //! Thread3
    pthread_t thread3;
    pthread_create(&thread3, NULL, odd_numbers, (void *)array);
    //! Thread4
    pthread_t thread4;
    pthread_create(&thread4, NULL, sum, (void *)array);
    //! JOINS
    int *even_numbers;
    int *odd_numbers;
    int *sum;
    pthread_join(thread2, (void **)&even_numbers);
    pthread_join(thread3, (void **)&odd_numbers);
    pthread_join(thread4, (void **)&sum);
    printf("Even Numbers: %d\n", *even_numbers);
    printf("Odd Numbers: %d\n", *odd_numbers);
    printf("SUM: %d\n", *sum);
    free(array);
    free(even_numbers);
    free(odd_numbers);
}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <fcntl.h>
#define SHM_SIZE 1024
key_t key = 999;

int main(int argc, char *argv[])
{
    //! Arranging the data
    int fd = open(argv[1], O_RDONLY);
    if (fd < 0)
    {
        printf("Unable to open");
        exit(EXIT_FAILURE);
    }
    char data[SHM_SIZE];
    read(fd, data, SHM_SIZE);
    close(fd);
    void *ptr;
    int id = 0;
    int unlink_status = 0;
    //! Create shared memory
    id = shmget(key, SHM_SIZE, IPC_CREAT | 0666);
    if (id < 0)
    {
        printf("SHMGET failed\n");
        return 2;
    }
    else
    {
        printf("ID = %d\n", key);
    }
    //! Attach the shared memory to current process
    ptr = shmat(id, NULL, 0);
    if (ptr == NULL)
    {
        printf("SHMAT failed \n");
        return 3;
    }
    // TODO:
    strcpy(ptr, data);
    printf("DATA: %s\n", (char *)data);
    printf("Shared memory: %s\n", (char *)ptr);
    sleep(10);
    //! Detach the shared memory
    unlink_status = shmdt(ptr);
    if (unlink_status < 0)
    {
        printf("SHMDT failed\n");
        return 3;
    }
    //! Delete the shared memory
    shmctl(key, IPC_RMID, NULL);
    return 0;
}


#include <unistd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
void my_own_signal_handler_hehe(int sig_num)
{
    if (sig_num == SIGCHLD)
    {
        printf("Received SIGCHLD\n");
    }
    exit(0);
}
int main()
{
    if (signal(SIGCHLD, my_own_signal_handler_hehe) == SIG_ERR)
        printf("Couldn't catch SIGINT\n");
    printf("Please enter the number of laps: ");
    int laps;
    scanf("%d", &laps);
    printf("Please enter the lap time: ");
    int time;
    scanf("%d", &time);
    pid_t pid = fork();
    if (pid)
    {
        wait(NULL);
        printf("Total time: %d!\n", laps * time);
    }
    else if (!pid)
    {
        for (int i = 1; i <= laps; i++)
        {
            for (int j = 1; j <= time; j++)
            {
                sleep(1);
            }
            printf("Lap: %d completed!\n", i);
        }
    }
}

#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <semaphore.h>
void *worker1();
void *worker2();
int s1, s2;
int x, y, w, z;
sem_t semaphore_variable;
int main(int argc, char *argv[])
{
    sem_init(&semaphore_variable, 0, 1);
    pthread_t thread1, thread2;
    printf("Enter the values of variables: \n");
    scanf("%d", &x);
    scanf("%d", &y);
    scanf("%d", &w);
    scanf("%d", &z);
    pthread_create(&thread1, NULL, worker1, NULL);
    pthread_create(&thread2, NULL, worker2, NULL);
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    return 0;
}
void *worker1()
{
    sem_wait(&semaphore_variable);
    x = z + 2;
    y = z * 5;
    s1 = x + y;
    sem_post(&semaphore_variable);
    printf("s1=%d\n", s1);
    pthread_exit(NULL);
}
void *worker2()
{
    sem_wait(&semaphore_variable);
    z = x * 2;
    w = y + 5;
    s2 = z + w;
    sem_post(&semaphore_variable);
    printf("s2=%d\n", s2);
    pthread_exit(NULL);
}

